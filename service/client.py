import os
import time
import sys
import grpc
from enum import Enum
import argparse
sys.path.append(os.path.join(os.path.dirname(__file__), "service_spec"))
import das_pb2 as pb2
import das_pb2_grpc as pb2_grpc
from server import SERVICE_PORT, AtomSpaceStatus


class ClientCommands(str, Enum):
    CREATE = "create"
    LOAD = "load"
    CHECK = "check"
    CLEAR = "clear"
    COUNT = "count"

def _check(response):
    assert response.success,response.msg
    return response
    
def main():
    parser = argparse.ArgumentParser(
        "GRPC client to access a DAS server", formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("--host", type=str, default="localhost", help="Host with DAS server")
    parser.add_argument("--port", type=str, default=f"{SERVICE_PORT}", help="DAS server port")
    parser.add_argument("command", 
        type=str, 
        help="Command to be executed in DAS server",
        choices=[command.value for command in ClientCommands])
    parser.add_argument("--new-das-name", type=str, default=f"das", help="Unique ID for a new DAS being created (used only in 'create' command)")
    parser.add_argument("--das-key", type=str, help="DAS access key (generated by 'create' command)")
    parser.add_argument("--url", type=str, help="URL pointing to a MeTTa (or .scm) file to be loaded. Optionally, the URL can point to a .tgz, .tar or .zip files containing MeTTa or .scm files.")

    args = parser.parse_args()
    command = args.command
    host = args.host
    port = args.port

    with grpc.insecure_channel(f"{host}:{port}") as channel:
        stub = pb2_grpc.ServiceDefinitionStub(channel)
        if command == ClientCommands.CREATE:
            assert args.new_das_name
            das_name = args.new_das_name
            response = _check(stub.create(pb2.CreationRequest(name=das_name)))
            print(f"New DAS '{das_name}' successfully created. Access key: {response.msg}")
        elif command == ClientCommands.LOAD:
            assert args.das_key
            assert args.url
            das_key = args.das_key
            url = args.url
            response = _check(stub.load_knowledge_base(pb2.LoadRequest(das_key=das_key, url=url)))
            print(f"Load request submitted. Check status using the command 'check'")
        elif command == ClientCommands.CHECK:
            assert args.das_key
            das_key = pb2.DASKey(key=args.das_key)
            response = _check(stub.check_das_status(das_key))
            print(f"{response.msg}")
        elif command == ClientCommands.CLEAR:
            assert args.das_key
            das_key = pb2.DASKey(key=args.das_key)
            response = _check(stub.clear(das_key))
        elif command == ClientCommands.COUNT:
            assert args.das_key
            das_key = pb2.DASKey(key=args.das_key)
            response = _check(stub.count(das_key))
            node_count, link_count = response.msg.split()
            print(f"{node_count} nodes {link_count} links")
    
def main_test():
    with grpc.insecure_channel(f"localhost:{SERVICE_PORT}") as channel:
        stub = pb2_grpc.ServiceDefinitionStub(channel)
        response = stub.create(pb2.CreationRequest(name="das"))
        print(response)
        das_key = pb2.DASKey(key=response.msg)
        service_input = pb2.LoadRequest(das_key=das_key.key, url="https://raw.githubusercontent.com/singnet/das/main/data/samples/animals.metta")
        response = stub.load_knowledge_base(service_input)
        print(response)
        while True:
            response = stub.check_das_status(das_key)
            print(response)
            if response.msg == AtomSpaceStatus.READY:
                break
            else:
                time.sleep(1)
        response = stub.clear(das_key)
        print(response)


if __name__ == "__main__":
    main()
