import os
import time
import sys
import grpc
from enum import Enum
import argparse
sys.path.append(os.path.join(os.path.dirname(__file__), "service_spec"))
import das_pb2 as pb2
import das_pb2_grpc as pb2_grpc
from server import SERVICE_PORT, AtomSpaceStatus, OutputFormat


class ClientCommands(str, Enum):
    CREATE = "create"
    LOAD = "load"
    CHECK = "check"
    CLEAR = "clear"
    COUNT = "count"
    SEARCH_LINKS = "search_links"
    SEARCH_NODES = "search_nodes"

def _check(response):
    assert response.success,response.msg
    return response
    
def main():
    parser = argparse.ArgumentParser(
        "GRPC client to access a DAS server", formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("--host", type=str, default="localhost", 
        help="Host with DAS server")
    parser.add_argument("--port", type=str, default=f"{SERVICE_PORT}", 
        help="DAS server port")
    parser.add_argument("command", type=str, 
        help="Command to be executed in DAS server",
        choices=[command.value for command in ClientCommands])
    parser.add_argument("--new-das-name", type=str, default=f"das", 
        help="Unique ID for a new DAS being created (used only in 'create' command).")
    parser.add_argument("--das-key", type=str, 
        help="DAS access key (generated by 'create' command).")
    parser.add_argument("--url", type=str, 
        help="URL pointing to a MeTTa (or .scm) file to be loaded. Optionally, the URL can point " + \
             "to a .tgz, .tar or .zip files containing MeTTa or .scm files.")
    parser.add_argument("--node-type", type=str, 
        help="Type of nodes being searched. Only nodes of the passed type will be returned.")
    parser.add_argument("--node-name", type=str, 
        help="Name of node being searched. Requires --node-type.")
    parser.add_argument("--link-type", type=str, 
        help="Type of links being searched. Only links of the passed type will be returned.")
    parser.add_argument("--target-types", type=str, 
        help="Target types being searched. If something like 'type1,type2' is passed, only links " + \
             "whose target types are 'type1' and 'type2' are returned.")
    parser.add_argument("--targets", type=str, 
        help="Target handles being searched. If something like 'key1,key2' is passed, only links " + \
             "whose targets are 'key1' and 'key2' are returned.")
    parser.add_argument("--output-format", default=f"{OutputFormat.HANDLE}",
        choices=[fmt.value for fmt in OutputFormat],
        help=f"Tells how the query output should be formatted. " + \
             f"'{OutputFormat.HANDLE}' returns only the handle of atoms that satisfy the query. This is the fastest " + \
             f"option as no overhead is added to post-process query results. " + \
             f"'{OutputFormat.DICT}' return more structured information about the atoms that matches the query but " + \
             f"handles (such as link targets) are not followed or post-processed. " + \
             f"'{OutputFormat.JSON}' post-processes the query output to recursively replace handles by its referenced " + \
             f"atoms. This is the most costly option.")

    args = parser.parse_args()
    command = args.command
    host = args.host
    port = args.port

    with grpc.insecure_channel(f"{host}:{port}") as channel:
        stub = pb2_grpc.ServiceDefinitionStub(channel)
        if command == ClientCommands.CREATE:
            assert args.new_das_name
            das_name = args.new_das_name
            response = _check(stub.create(pb2.CreationRequest(name=das_name)))
            print(f"New DAS '{das_name}' successfully created. Access key: {response.msg}")
        elif command == ClientCommands.LOAD:
            assert args.das_key
            assert args.url
            das_key = args.das_key
            url = args.url
            response = _check(stub.load_knowledge_base(pb2.LoadRequest(das_key=das_key, url=url)))
            print(f"Load request submitted. Check status using the command 'check'")
        elif command == ClientCommands.CHECK:
            assert args.das_key
            das_key = pb2.DASKey(key=args.das_key)
            response = _check(stub.check_das_status(das_key))
            print(f"{response.msg}")
        elif command == ClientCommands.CLEAR:
            assert args.das_key
            das_key = pb2.DASKey(key=args.das_key)
            response = _check(stub.clear(das_key))
        elif command == ClientCommands.COUNT:
            assert args.das_key
            das_key = pb2.DASKey(key=args.das_key)
            response = _check(stub.count(das_key))
            node_count, link_count = response.msg.split()
            print(f"{node_count} nodes {link_count} links")
        elif command == ClientCommands.SEARCH_NODES:
            assert args.das_key
            assert args.node_type
            das_key = args.das_key
            node_type = args.node_type
            node_name = args.node_name if args.node_name else None
            output_format = args.output_format
            node_request = pb2.NodeRequest(
                das_key=das_key,
                node_type=node_type,
                node_name=node_name,
                output_format=output_format)
            response = _check(stub.search_nodes(node_request))
            print(f"{response.msg}")
        elif command == ClientCommands.SEARCH_LINKS:
            assert args.das_key
            das_key = args.das_key
            link_type = args.link_type if args.link_type else None
            target_types = args.target_types.split(",") if args.target_types else None
            targets = args.targets.split(",") if args.targets else None
            output_format = args.output_format
            link_request = pb2.LinkRequest(
                das_key=das_key,
                link_type=link_type,
                target_types=target_types,
                targets=targets,
                output_format=output_format)
            response = _check(stub.search_links(link_request))
            print(f"{response.msg}")
    
def main_test():
    with grpc.insecure_channel(f"localhost:{SERVICE_PORT}") as channel:
        stub = pb2_grpc.ServiceDefinitionStub(channel)
        response = stub.create(pb2.CreationRequest(name="das"))
        print(response)
        das_key = pb2.DASKey(key=response.msg)
        service_input = pb2.LoadRequest(das_key=das_key.key, url="https://raw.githubusercontent.com/singnet/das/main/data/samples/animals.metta")
        response = stub.load_knowledge_base(service_input)
        print(response)
        while True:
            response = stub.check_das_status(das_key)
            print(response)
            if response.msg == AtomSpaceStatus.READY:
                break
            else:
                time.sleep(1)
        response = stub.clear(das_key)
        print(response)


if __name__ == "__main__":
    main()
